# Структура управления памятью
В python используется объектный распределитель памяти (PyMalloc), который управляет небольшими объектами (<=512 байт) через пулы и арены


- Арена - 256 kb
	- Содержит 64 пула (по 4 kb)
	- Выделяется с помощью (mmap или malloc) и освобождается, когда пустая
- Пул - 4 kb
	- Выделяется из арены
	- Хранит блоки одинакового размера
	- Может быть в трех состояниях: 
		- used (использован частично)
		- full (заполнен)
		- empty (может быть возвращен арене)
- Блок - 8 - 512 байт
	- Используется доя хранения небольших объектов
	- Размер увеличивается степенями 2
	- Для объектов (больше 512 байт), выделяется напрямую через malloc

# Сборщик мусора - GC
## Подсчет ссылок (Reference Counting)
Когда на объект не остается больше ссылок, он сразу удаляется из памяти 

``` python
print(sys.getrefcount(a)) #  Сколько ссылок
```


## Проблема циклических ссылок
Если два объекта ссылаются друг на друга, их счетчик ссылок никогда не станет 0, что приводит к утечке памяти

GC в python решает проблему циклических ссылок с помощью подсчета поколений объектов.

1. Все объекты делятся на 3 покаления (0, 1, 2)
2. Новые объекты попадают в поколение 0
3. Если объект не удалился после нескольких проверок он перемещается в старшее поколение
4. Чем реже объект, тем реже он проверяется
5. GC, запускается автоматически, когда количество новых объектов превышает порог


Ручной контроль GC

``` python
import gc

gc.collect()  # Принудительный запуск сборщика мусора
gc.disable()  # Отключить автоматический GC
gc.enable()   # Включить обратно

# Проверить количество объектов в поколениях:
print(gc.get_count())  # (поколение 0, поколение 1, поколение 2)

 # Изменить лимиты запуска GC
gc.set_threshold(700, 10, 10) 
```