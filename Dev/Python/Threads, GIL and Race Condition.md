В Python переключение между потоками происходит **каждые 5 мс** (по умолчанию) или в моменты, когда поток **ожидает ввода-вывода (I/O)**, а так же при использовании блокировок, когда один ожидает другой.

- Для CPU-bound задач, GIL сильно замедляет параллельное выполнение, т.к. потоки поочередно захватывают GIL, и не выполняются параллельно
- Для IO-bound задач, многопоточность работает хорошо, т.к. GIL освобождается во время ожидания. 

Оптимальная пропорция процессов на ядро - 1/1, т.е. для выполнения CPU-bound задач нужно выделять столько процессов, сколько ядер в CPU

## GIL не предотвращает состояние гонки
  Т.к. GIL предотвращает race condition только на уровне интерпретатора, но не гарантирует атомарность операций на уровне потоков. Это означает, что переключение потоков может происходить посередине операций, каждущихся "простыми" (например, увеличение счетчика)


``` python
import threading

counter = 0

def increment()
	global counter
	for _ in range(1000000):
		counter += 1 # Неатомарная операция
	
threads = [threading.Thread(target=increment) for _ in range(2)]
for t in threads: t.start()
for t in threads: t.join()


print(counter)  # Ожидается 2_000_000, но результат может быть меньше
```

- Почему `counter += 1` на самом деле представляет собой 3 операции
  1. Прочесть значение counter из памяти
  2. Увеличить его на 1
  3. Записать новое значение в память
     
Если поток переключиться между этими шагами, другой поток, другой поток может выполнить те же операции но с устаревшим значением, что приведет к потере инкремента.


## GIL не действует на C-расширения
Многие библиотеки (например, numpy) выполняются без ограничения GIL, потому что используют освобождение GIL в нативном C-коде, если несколько потоков используют такие библиотеки возможно гонка данных 


## Race condition возможна в multiprocessing

При использовании общей памяти между процессами (например, multiprocessing.Value или multiprocessing.Array)



# Как избежать race condition
- threading.Lock
- queue.Queue
- concurrent.futures.ThreadPoolExecutor