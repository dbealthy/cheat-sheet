## Chain/Group/Chord
- Chain позволяет выполнить таски потенциально на разных воркерах, что позволяет оптимизировать процесс обработки, за счет передачи данных из одного воркера результов другому
  
- Group позволяет запустить таски параллельно, и получить результат из всех тасков. Для каждой группы отдельный результат.
  
- Chord похож на группу, но позволяет добавить callback, который принимет результаты выполнения всех задач из группы и аггрегировать их например.

## Что будет если запустить celery-beat в нескольких процессах или в нескольких подах

Запуск `celery-beat` в нескольких процессах или подах приводит к дублированию задач и потенциальным сбоям (в том числе к dead lock), потому что каждый beat worker будет считать себя ответственным за создание задач и пытать конкурентно обновлять расписание. Лучше всего:

- Убедиться, что работает только один экземпляр `celery-beat`,
- Использовать блокировки или специализированные планировщики для обеспечения высокой доступности.

django celery beat хранит данные в базе, что позволяет реализовать кастомный механизм для реализации синхронизации (Locking)



## Очереди в Celery: Что это и зачем нужны?

Очереди в Celery — это механизм маршрутизации задач между различными исполнителями (воркерами). Они позволяют разделять задачи по категориям, приоритетам или специфике обработки, направляя их в разные очереди.

---

### **Зачем нужны очереди?**

1. **Разделение задач**:
    
    - Вы можете направлять разные типы задач в отдельные очереди, чтобы они обрабатывались независимо. Например:
        - Очередь `emails` для отправки писем.
        - Очередь `reports` для генерации отчетов.
2. **Приоритеты обработки**:
    
    - Высокоприоритетные задачи могут обрабатываться в отдельной очереди с выделенными ресурсами.
3. **Оптимизация ресурсов**:
    
    - Выделение отдельных воркеров для обработки тяжелых задач, чтобы они не блокировали другие задачи.
4. **Масштабируемость**:
    
    - Вы можете масштабировать обработку задач для конкретной очереди, добавляя больше воркеров.
5. **Логика маршрутизации**:
    
    - Celery позволяет направлять задачи в очереди на основе их свойств, например, используя `routing_key`.

---

### **Сколько можно назначить воркеров на одну очередь?**

- **Теоретически:** Количество воркеров, которые можно назначить на очередь, не ограничено Celery.
- **Практически:** Зависит от доступных ресурсов (CPU, память) и характера задач:
    - Если задачи лёгкие, большее количество воркеров может эффективно ускорить обработку.
    - Если задачи тяжёлые и используют много ресурсов, количество воркеров должно быть ограничено ресурсами сервера.

---

### **Как назначить воркеров на очереди?**

#### 1. **Создание очередей**

Очереди определяются в вашем брокере сообщений (например, RabbitMQ, Redis). В Celery они задаются через конфигурацию:

```python
CELERY_QUEUES = {
    "default": {
        "exchange": "default",
        "exchange_type": "direct",
        "routing_key": "default"
    },
    "emails": {
        "exchange": "emails",
        "exchange_type": "direct",
        "routing_key": "emails"
    },
    "reports": {
        "exchange": "reports",
        "exchange_type": "direct",
        "routing_key": "reports"
    }
}
```

#### 2. **Маршрутизация задач**

Каждая задача может быть направлена в определённую очередь, указав `queue` в декораторе:

```python
from celery import Celery

app = Celery('tasks')

@app.task(queue='emails')
def send_email():
    print("Sending email")

@app.task(queue='reports')
def generate_report():
    print("Generating report")

```
#### 3. **Запуск воркеров для очередей**

Для обработки задач из определённых очередей можно указать их при запуске воркера:
``` bash
celery -A your_project worker --loglevel=info --queues emails,reports
```
- **Обработка всех очередей:** По умолчанию воркер обрабатывает задачи из всех доступных очередей.
- **Обработка конкретных очередей:** Если указаны очереди через параметр `--queues`, воркер будет обрабатывать только эти очереди.

#### 4. **Настройка количества воркеров**
``` bash
celery -A your_project worker --loglevel=info --queues emails --concurrency 4
```
Количество воркеров определяется параметром `--concurrency` при запуске:


## Конкурентное обращение к общим ресурсам в тасках celery воркеров. Например если один воркер попытается изменить глобальное состояние, например обновить что то в модуле с настройками. Изменится ли состояние в других воркерах. И как можно ограничить доступ к этим настройкам.

- **Изменения в глобальных настройках одного воркера не распространяются на другие, так как каждый воркер изолирован.**
- Чтобы синхронизировать настройки между воркерами или ограничить доступ, используйте:
    1. Внешние хранилища (база данных, Redis).
    2. Механизмы блокировки.
    3. Передачу данных через брокер сообщений или backend Celery.

1. **Изоляция зависит от модели параллелизма:**
    
    - Если Celery использует **процессы** (по умолчанию), каждый воркер изолирован, и изменения глобального состояния в одном воркере не влияют на другие.
    - Если используется **многопоточность** или **greenlet** (например, через **eventlet** или **gevent**), все потоки/`greenlet`ы разделяют общее пространство памяти, и изменения в глобальных переменных будут видны всем.
2. **Риски в многопоточности:**
    
    - При работе в одном процессе (с потоками или `greenlet`) существует риск возникновения **состояний гонки** (_race conditions_), что может привести к некорректному поведению, если несколько воркеров одновременно изменяют общий ресурс.
3. **Рекомендации:**
    
    - **Избегайте изменения глобального состояния**: передавайте данные через параметры задач или используйте внешние хранилища (например, Redis, базы данных).
    - Если необходимо работать с общим ресурсом:
        - Используйте **механизмы синхронизации** (например, `threading.Lock`, Redis-блокировки).
        - Рассмотрите **потокобезопасные структуры данных** (например, `queue.Queue`).
    - **Используйте многопроцессность**, если ваши задачи требуют интенсивного использования CPU или вы хотите избежать проблем с глобальным состоянием.
4. **Приоритетная модель:**
    
    - По умолчанию рекомендуется использовать **многопроцессный подход**, так как он обеспечивает лучшую изоляцию и масштабируемость без необходимости ручной синхронизации.

💡 Если нужно использовать многопоточность или `greenlet`, убедитесь, что состояние изолировано, синхронизировано или управляется через внешние системы.