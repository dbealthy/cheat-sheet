Называют Высокое зацепление

- Похож на [[SRP]]
- Создает ограничение для [[4. Low Coupling]], не давая сделать один GOD класс, в котором будет все
- Позволяет объяснять почему [[Плохой код]]
- Классы и модули helper, utils противоречат этому принципу
- Обесппечивая большее зацепление, мы избавляемся от лишних зависимостей, перемещая весь схожий код вместе, за счет чего клиент становится проще и имеет меньше зависимостей
## Проблема
Необходимо обеспечить выполнение объектами разнородных функций.

## Решение
Обеспечить распределение обязанностей с высоким зацеплением

**Все методы класса должны быть логически друг с другом зацеплены. Должны отноститься к одному и тому же, отвечать за одно дело**


## Преимущества
- Классы с высоким зацеплением просты в поддержке и повторном переиспользовании

## Недостатки
- С точки зрения практического применения приходится нарушать принцип, когда класс делает внешние вызовы (сетевые, бд). Мы должны отделить все что связанно с внешними вызовами в отдельный класс со слабым зацеплением. Даже если класс логически взаимосвязан с внешними вызовани, внешние вызовы **всегда отедляются**, чтобы было легче переиспользовать код и изменять. Геттеры сеттеры отдельно, сетевые вызовы отедльно



Плохое решение
``` python
class DateTemperature:
	def __init__(self, temperature, timestamp):
		self._temperature = temperature
		self._timestamp = timestamp
		
	def get_temp_C(self):
		return self._temperature
		
	def get_temp_F(self):
		return (self._temperature - 32) / 1.8

	def _get_measure_time(self):
		return self.timestamp.time()

	def get_product(self):
		return self.get_temp_F() * self._get_measure_time()
```


Хорошее решение
``` python

class Temperature:
	def __init__(self, value_c):
		self._value_c = value_c

	def get_temp_C(self):
		return self._value_c

	def get_temp_F(self):
		return (self._temperature - 32) / 1.8

class Timestamp:
	def __init__(self, dt):
		self._dt = dt

	def get_measure_time(self):
		return self.timestamp.time()


class MeasureDevice:
	def __init__(self, temperature_c, dt):
		self._temperature = Temperature(temperature_c)
		self._timestamp = Timestamp(dt)

	def get_temp_C(self):
		return self._temperature.get_temp_C()
		
	def get_temp_F(self):
		return self._temperature.get_temp_F()

	def get_product(self):
		return self.temperatire.get_temp_F() * self.timestamp.get_measure_time()


```

В хорошей реализации классы Temperature и Timestamp можно переиспользовать, а в плохом нет. Хорошая реализация избавляет от дублирования кода